#!/usr/bin/env node
"use strict";

const fs = require("fs");
const path = require("path");
const readline = require("readline");

const { convertLineToEntry } = require("./src/lib");

/**
 * CLI:
 *   node translate-gen.js --in translates.txt --out new_translates.json --base .
 * Options:
 *   --in <file>          Input file (default: translates.txt)
 *   --out <file>         Output file (default: new_translates.json)
 *   --base <dir>         Base directory for in/out paths (default: process.cwd())
 *   --mode <json|js>     Output as JSON object or JS module (default: json)
 *   --pretty             Pretty JSON (2 spaces)
 *   --no-remove-quotes   Keep quotes «»"' in original value (default: remove)
 *   --help               Show help
 */

function printHelp() {
  const help = `
translate-gen (Node.js)

Usage:
  node translate-gen.js [--in <file>] [--out <file>] [--base <dir>] [--mode json|js] [--pretty] [--no-remove-quotes]

Examples:
  node translate-gen.js
  node translate-gen.js --in translates.txt --out new_translates.json
  node translate-gen.js --base ./i18n --in raw.txt --out en.json --pretty
  node translate-gen.js --in raw.txt --out dict.js --mode js --pretty

Rules:
  - Key is generated from CLEANED value (quotes removed by default)
  - Parse key:value or key=value ONLY if the whole line is NOT wrapped in quotes
  - Duplicate keys become: key_2, key_3...
`;
  process.stdout.write(help.trimStart() + "\n");
}

function parseArgs(argv) {
  const args = {
    in: "translates.txt",
    out: "new_translates.json",
    base: process.cwd(),
    mode: "json",
    pretty: false,
    removeQuotes: true,
    help: false,
  };

  for (let i = 2; i < argv.length; i++) {
    const a = argv[i];

    if (a === "--help" || a === "-h") {
      args.help = true;
      continue;
    }

    if (a === "--pretty") {
      args.pretty = true;
      continue;
    }

    if (a === "--no-remove-quotes") {
      args.removeQuotes = false;
      continue;
    }

    if (a === "--in" || a === "-i") {
      const v = argv[++i];
      if (!v) throw new Error("Missing value for --in");
      args.in = v;
      continue;
    }

    if (a === "--out" || a === "-o") {
      const v = argv[++i];
      if (!v) throw new Error("Missing value for --out");
      args.out = v;
      continue;
    }

    if (a === "--base" || a === "-b") {
      const v = argv[++i];
      if (!v) throw new Error("Missing value for --base");
      args.base = v;
      continue;
    }

    if (a === "--mode" || a === "-m") {
      const v = argv[++i];
      if (!v) throw new Error("Missing value for --mode");
      if (v !== "json" && v !== "js")
        throw new Error("Invalid --mode. Use json or js.");
      args.mode = v;
      continue;
    }

    throw new Error(`Unknown argument: ${a}`);
  }

  args.base = path.resolve(args.base);

  if (!path.extname(args.out)) {
    args.out += args.mode === "js" ? ".js" : ".json";
  }

  return args;
}

async function main() {
  let args;
  try {
    args = parseArgs(process.argv);
  } catch (e) {
    process.stderr.write(String(e && e.message ? e.message : e) + "\n\n");
    printHelp();
    process.exitCode = 1;
    return;
  }

  if (args.help) {
    printHelp();
    return;
  }

  const inputPath = path.resolve(args.base, args.in);
  const outputPath = path.resolve(args.base, args.out);

  try {
    await fs.promises.access(inputPath, fs.constants.R_OK);
  } catch (e) {
    process.stderr.write(`Cannot read input file: ${inputPath}\n`);
    process.stderr.write(`Error: ${String(e && e.message ? e.message : e)}\n`);
    process.exitCode = 1;
    return;
  }

  const rl = readline.createInterface({
    input: fs.createReadStream(inputPath, { encoding: "utf8" }),
    crlfDelay: Infinity,
  });

  const dict = {};
  const usedKeys = new Set();

  let lineCount = 0;
  let keptCount = 0;
  let parsedCount = 0;
  let autoCount = 0;

  rl.on("line", (line) => {
    lineCount++;

    const entry = convertLineToEntry(
      line,
      { removeQuotes: args.removeQuotes },
      usedKeys,
    );

    if (!entry) return;

    dict[entry.key] = entry.value;
    keptCount++;

    if (entry.mode === "parsed") parsedCount++;
    else autoCount++;
  });

  await new Promise((resolve, reject) => {
    rl.on("close", resolve);
    rl.on("error", reject);
  });

  const json = args.pretty
    ? JSON.stringify(dict, null, 2)
    : JSON.stringify(dict);

  let outputContent;
  if (args.mode === "js") {
    outputContent = `// Generated by translate-gen\nexport default ${json};\n`;
  } else {
    outputContent = json + "\n";
  }

  await fs.promises.mkdir(path.dirname(outputPath), { recursive: true });

  const tmpPath = outputPath + ".tmp";
  await fs.promises.writeFile(tmpPath, outputContent, { encoding: "utf8" });
  await fs.promises.rename(tmpPath, outputPath);

  process.stdout.write(
    `OK: ${keptCount}/${lineCount} lines converted\n` +
      `Parsed key/value: ${parsedCount}\n` +
      `Auto-generated:  ${autoCount}\n` +
      `Input:  ${inputPath}\n` +
      `Output: ${outputPath}\n`,
  );
}

main().catch((e) => {
  process.stderr.write(`Fatal: ${String(e && e.message ? e.message : e)}\n`);
  process.exitCode = 1;
});
